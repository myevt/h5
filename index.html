<html>
  <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  </head>
  <body>
    <script type="text/javascript">Object.assign=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target}</script>
    <script type="text/javascript" src="js/evt.js"></script>
    <script type="text/javascript" src="js/keythereum.js"></script>
    <script type="text/javascript" src="js/myWallet.min.js"></script>
    <script type="text/javascript" src="js/web3.js"></script>
    <script type="text/javascript" src="js/hooked-web3-provider.js"></script>
    <script type="text/javascript" src="js/eos.min.js"></script>
    <script type="text/javascript">
      var passport = (function(){
        var passwordProvider = function() {}
        passwordProvider.prototype.setPwd = function(password) {
          this.password = password;
        }
        passwordProvider.prototype.getPwd = function() {
          password = this.password
          return password
        }
        return new passwordProvider()
      })()

      var evtKeyProviders = (function(){
        var p = function(){
          this.keys = {}
          this.payer = ""
          this.maxCharge = 1000000
        }
        p.prototype.setPayer = function(payer) {
          this.payer = payer
          BNOK("evtKeyProviders.setPayer")
        }
        p.prototype.setMaxCharge = function(maxCharge) {
          this.maxCharge = maxCharge
          BNOK("evtKeyProviders.setMaxCharge")
        }
        p.prototype.import = function(privKey, isPayer) {
          if (EVT.EvtKey.isValidPrivateKey(privKey)) {
            var publicKey = EVT.EvtKey.privateToPublic(privKey)
            this.keys[publicKey] = privKey
            if (typeof isPayer !== "undefined" && isPayer) {
              this.payer = publicKey
            }
            BNOK("evtKeyProviders.import")
          } else {
            BNMessage("evtKeyProviders.import", "Invalid key")
          }
          
        }
        p.prototype.export = function(curPrivKey) {
          var k = [curPrivKey], keys = this.keys
          Object.keys(keys).map(function(pub){k.push(keys[pub])})
          return k
        }

        p.prototype.addresses = function(re) {
          var addrs = Object.keys(this.keys)
          if (typeof wallets.evt !== "undefined") {
            addrs.unshift(wallets.evt.getAddresses()[0])
          }
          if (typeof re === "undefined") {
            BNMessage("evtKeyProviders.addresses", null, addrs)
          } else {
            return addrs
          }
        }

        p.prototype.pushConfig = function() {
          return {payer: this.payer || wallets.evt.getAddresses()[0], maxCharge: this.maxCharge}
        }

        return new p()
      })()

      function isHex(str) {
        if (str.length % 2 === 0 && str.match(/^[0-9a-f]+$/i)) {
          return true
        }else{
          return false
        }
      }

      /**
       * is Valid address EVT\EOS\ETH
       * @param  string address
       * @return {[type]}         [description]
       */
      function isValidAddress(address) {
        var s3 = address.substr(0,3)
        if (s3 == "EOS") {
          address = "EVT"+address.substr(3)
          s3 = "EVT"
        }

        var valid = false;
        if (s3 == "EVT") {
          valid = EVT.EvtKey.isValidAddress(address)
        } else {
          // eth address
          if (address.substr(0,2).toLowerCase() == "0x") {
            address = address.substr(2)
          }
          valid = isHex(address) && address.length==40
        }

        BNMessage("isValidAddress", !valid, '')
      }

      /**
       * is Valid PrivateKey EVT\EOS\ETH
       * @param  string prik
       * @return {[type]}         [description]
       */
      function isValidPrivateKey(prik) {
        var valid = false
        valid = EVT.EvtKey.isValidPrivateKey(prik) || (isHex(prik) && prik.length===64)

        BNMessage("isValidPrivateKey", !valid, '')
      }

      /**
       * is Valid GroupDef
       * @param  object group
       * @return {[type]}         [description]
       */
      function isValidGroupDef(group) {
        var _nodes = group.root && group.root.nodes
        if (_nodes) {
          var haveDieNode = evtGroupDieNodes(_nodes, group.root.threshold)
          BNMessage("isValidGroupDef", haveDieNode)
        } else {
          BNMessage("isValidGroupDef", "Invalid group def")
        }
      }

      function evtGroupDieNodes(nodes, threshold) {
        var weightCount = 0
        
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes[i];
          if (typeof node.nodes === "object") {
            if(evtGroupDieNodes(node.nodes, node.threshold) ) {
              return true
            }
          }
          weightCount += node.weight
        }
        return weightCount < threshold
      }

      // myWallet.HDkey.generateMnemonic() 助记词
      // web3.eth.sendTransaction({from: '627306090abab3a6e1400e9345bc60c78a8bef57', to: "f17f52151ebef6c7334fad080c5704d77216b732", value: 10*1.0e18, gasPrice: 18000000000, gas: 50000},(err, txid)=>console.log(err,txid))
      var web3 = new Web3();
      var apiCaller = {};
      var eos = {};
      var wallets = {};
      // 需要用到密码钱先设置用户密码 passport.setPwd('password')
      /**
       * 创建钱包
       * @param  {type:"evt",seedPhrase:"candy maple cake sugar pudding cream honey rich smooth crumble sweet treat",hdPathString:"m/44'/207'/0'/0",password:"abcd1234"}
       * @return {[type]}         [description]
       */
      function createHDkey(options) {
        myWallet.HDkey.create(options,function(error, ks){
          initHDkey(ks);
          BNMessage("createHDkey", error, ks.serialize());
        });
      }

      /**
       * generateMnemonic
       * @return {[type]} [description]
       */
      function generateMnemonic()
      {
        var words = myWallet.HDkey.generateMnemonic()
        BNMessage("generateMnemonic", null, words);
      }

      /**
       * exportMnemonic
       * @param  string password
       * @param  string ksName
       * @return {[type]}          [description]
       */
      function exportMnemonic(password, ksName)
      {
        if (typeof wallets[ksName] === "undefined") {
          throw new Error("Please initHDkey first!")
        }
        var ks = wallets[ksName]
        ks.keyFromPassword(password,function(err,pw){
          if (!ks.isDerivedKeyCorrect(pw)) {
            BNMessage("exportMnemonic", "Password error")
          } else {
            var words = wallets[ksName].getMnemonic(pw)
            BNMessage("exportMnemonic", null, words)
          }
        })
      }

      
      /**
       * exportKeystore
       * @param  string password [description]
       * @param  string ksName   [description]
       */
      function exportKeystore(password, ksName) {
        if (typeof wallets[ksName] === "undefined") {
          throw new Error("Please initHDkey first!")
        }

        var ks = wallets[ksName]
        ks.keyFromPassword(password,function(err,pw){
          if (!ks.isDerivedKeyCorrect(pw)) {
            BNMessage('exportKeystore', "Password error")
          } else {
            var prik = ks.exportPrivateKey(ks.getAddresses()[0], pw)
            var dk = keythereum.create({ivBytes: 16 })
            dk.privateKey = keythereum.str2buf(prik)
            var options = {
              kdf: "pbkdf2",
              cipher: "aes-128-ctr",
              kdfparams: {
                c: 262144,
                dklen: 32,
                prf: "hmac-sha256"
              }
            }
            var keyObject = keythereum.dump(password, dk.privateKey, dk.salt, dk.iv, options)
            BNMessage("exportKeystore", null, keyObject)
          }
        })
      }

      /**
       * exportPrivatekey
       * @param  string password
       * @param  string ksName
       * @return {[type]}          [description]
       */
      function exportPrivatekey(password, ksName) {
        if (typeof wallets[ksName] === "undefined") {
          throw new Error("Please initHDkey first!")
        }

        var ks = wallets[ksName]
        ks.keyFromPassword(password,function(err,pw){
          if (!ks.isDerivedKeyCorrect(pw)) {
            BNMessage('exportPrivatekey', "Password error")
          } else {
            var prik = ks.exportPrivateKey(ks.getAddresses()[0], pw)
            BNMessage("exportPrivatekey", null, prik)
          }
        })
      }

      /**
       * importKeystore
       * @param  string        password
       * @param  string|object ks       keystore or keystore jsonstring
       * @return {[type]}          [description]
       */
      function importKeystore(password, ks) {
        if (typeof ks === "string") {
          ks = JSON.parse(ks)
        }
        try {
          keythereum.recover(password, ks, function (privateKey) {
            initPrivkey(web3.toHex(String.fromCharCode.apply(null, privateKey)).substr(2), password, 'eth')
          });
        } catch(e) {
          BNMessage("importKeystore", e)
        }
      }

      /**
       * checkWalletPassword
       * @param  string password
       * @param  string ks       wallet name
       * @return {[type]}          [description]
       */
      function checkWalletPassword(password, ks) {
        var wallet = wallets[ks]
        wallet.keyFromPassword(password,function(err,pw){
          if(wallet.isDerivedKeyCorrect(pw)) {
            BNOK('checkWalletPassword')
          } else {
            BNMessage('checkWalletPassword', "Password error")
          }
        })
      }

      /**
       * initHDkey Mnemonic wallet
       * @param  hdkey objcet or hdkey serialize string
       * @return {[type]}    [description]
       */
      function initHDkey(ks) {
        if (typeof ks === "object" && ks.getAddresses === undefined) {
          ks = JSON.stringify(ks)
        }

        if (typeof ks === "string") {
          ks = myWallet.HDkey.unserialize(decodeURIComponent(ks))
        }

        if (ks.type === undefined) {
          throw new Error("initHDkey")
        }

        if (ks.type == 'eth') {
          ks.passwordProvider = function(cb) {
            cb(null,  passport.getPwd())
          }
        }

        wallets[ks.type] = ks
        BNOK("initHDkey");
      }

      /**
       * initPrivkey
       * @param  string privKey
       * @param  string password
       * @param  string type     wallet name
       * @return {[type]}          [description]
       */
      function initPrivkey(privKey, password, type)
      {
        var addr = '';
        if (type == 'eth') {
          addr = "0x" + myWallet.pks.privkey2address(privKey)
        } else if(type=="eos") {
          addr = "EOS" + EVT.EvtKey.privateToPublic(privKey).substr(3)
        } else {
          addr = EVT.EvtKey.privateToPublic(privKey)
        }
        myWallet.pks.create({privKey:privKey, password:password, address:addr},function(err,k){
          if (err) {
            return BNMessage('initPrivkey', err)
          }
          wallets[type] = k
          BNMessage('initPrivkey', null, k)
        })
      }

      /**
       * init Privkey Wallet
       * @param  string|object ks   privkey object
       * @param  string type   wallet name
       * @return {[type]}      [description]
       */
      function initPrivkeyWallet(ks, type) {
        if (typeof ks === "object") {
          ks = JSON.stringify(ks)
        }
        wallets[type]=myWallet.pks.unserialize(ks)
        BNOK("initPrivkeyWallet")
      }

      /**
       * set Web3js Provider
       * @param string host eth node
       */
      function setWeb3Provider(host) {
        if (wallets.eth === undefined) {
          return BNMessage("setWeb3Provider","Please initHDkey first!");
        }

        wallets.eth.passwordProvider = function(cb) {
          cb(null, passport.getPwd())
        }

        var web3Provider = new HookedWeb3Provider({
          host: host,
          transaction_signer: wallets.eth
        });

        web3.setProvider(web3Provider)
        BNOK("setWeb3Provider")
      }

      /**
       * setEvtProvider 
       * 
       * @param object network eg. {
            host: 'testnet1.everitoken.io',
            port: 8888,
            protocol: 'https'
          }
       */
      function setEvtProvider(network) {
        if (wallets.evt === undefined) {
          return BNMessage("setEvtProvider", "Please initHDkey first!");
        }

        apiCaller = EVT({
            endpoint: network,
            keyProvider: function(transaction) {
              var password = passport.getPwd();
              return new Promise(function(resolve, reject){
                var ks = wallets.evt
                ks.keyFromPassword(password,function(err,pw){
                  if (err || !ks.isDerivedKeyCorrect(pw)) {
                    reject("Password error")
                  } else {
                    var keys = evtKeyProviders.export(ks.exportPrivateKey(ks.getAddresses()[0], pw))
                    resolve(keys)
                  }
                })
              })
            }
        });

        BNOK("setEvtProvider")
      }

      /**
       * set EOS provider 
       * 
       * @param string chainId
       * @param string httpEndpoint
       */
      function setEosProvider(chainId, httpEndpoint) {
        if (wallets.eos === undefined) {
          return BNMessage("setEosProvider", "Please initHDkey first!");
        }

        eosConfig = {
          chainId: chainId,
          httpEndpoint: httpEndpoint,
          verbose: true,
          keyProvider: function(transaction) {
            var password = passport.getPwd();
            return new Promise(function(resolve, reject){
              var ks = wallets.eos
              ks.keyFromPassword(password,function(err,pw){
                if (err || !ks.isDerivedKeyCorrect(pw)) {
                  reject("Password error")
                } else {
                  var key = ks.exportPrivateKey(ks.getAddresses()[0], pw)
                  resolve([key])
                }
              })
            })
          }
        }
        eos = Eos(eosConfig)
      }

      function evtGetUniqueLinkId() {
        EVT.EvtLink.getUniqueLinkId().then(function(result){BNMessage("evtGetUniqueLinkId", null, result)}).catch(function(err){BNMessage("evtGetUniqueLinkId", err)})
      }

      function evtLink(qrType, qrParams, imgPrams) {
        imgPrams = {autoReload: false}
        try {
          EVT.EvtLink.getEVTLinkQrImage(qrType, qrParams, imgPrams, 
              function(err, res) {
                if (err) {
                  return BNMessage("evtLink", err)
                }
                BNMessage("evtLink", null, res.dataUrl)
          });
        } catch(e) {
          BNMessage("evtLink", e)
        }
      }

      // QrCode Action
      function getQrCodeAction(qrText) {
        try {
            var action = JSON.parse(qrText)
            return BNMessage("getQrCodeAction", null, action)
        } catch (error) {}

        EVT.EvtLink.parseEvtLink(qrText).then(function(result){
            if ((result.flag & 1) !== 1) {
              return BNMessage("getQrCodeAction", "evtLink protocol version 1 (required)")
            }
            var action = {func: "", timestamp: 0, arg1: "", arg2: ""}
            for (var i = 0; i < result.segments.length; i++) {
              switch (result.segments[i].typeKey) {
                case 42:
                  action.timestamp = result.segments[i].value
                  break;
                case 44:
                case 91:
                  action.arg1 = result.segments[i].value + ""
                  break;
                case 43:
                case 45:
                case 92:
                case 94:
                  action.arg2 = result.segments[i].value + ""
                  break;
                case 95:
                  action.arg1 = result.segments[i].value
                  break;
              }
              
            }
            if ((result.flag & 2) === 2) { // everiPass
              action.func = "everiPass"
            }

            if ((result.flag & 4) === 4) { // everiPay
              action.func = "everiPay"
            }

            if ((result.flag & 16) === 16) { // payeecode
              action.func = "payeecode"
            }
            
            BNMessage("getQrCodeAction", null, action)
          }).catch(function(err){BNMessage("getQrCodeAction", err)})
      }

      // everiPay
      function evt_everiPay(password, abi) {
        passport.setPwd(password)
        _evtPushTransaction("evt_everiPay", [new EVT.EvtAction("everipay", abi, '.fungible', parseInt(abi.number.split(" S#")[1]))])
      }

      // everiPass
      function evt_everiPass(password, abi) {
        passport.setPwd(password)
        _evtPushTransaction("evt_everiPass", [new EVT.EvtAction("everipass", abi)])
      }

      function BNMessage(target, error, result){
        passport.setPwd("")
        if (typeof result !== "string") {
          result = JSON.stringify(result)
        }
        var data = {}
        if (error) {
          var errorCode = 1
          if (typeof error === "object") {
            console.log(error)
            if (error.isServerError) {
              errorCode = error.serverError.code
              error = error.serverError.what
            } else {
              error = error.message
            }
          }
          data = {target: target, error: errorCode, errorMessage: error}
        } else {
          data = {target: target, error:0, data: result}
        }
        var dataStr = '';
        Object.keys(data).forEach(function(key){
          dataStr += key+'='+encodeURIComponent(data[key])+'&';
        })
        console.log(data);
        // window.location.href = "wallet://return?" + dataStr
      }

      function BNOK(target)
      {
        BNMessage(target, null, "OK");
      }

      /**
       * get evtLink (payeecode)
       * @param  string evtpublic EVT address
       * @param  integer fungibleId
       */
      function evt_payeeCode(evtpublic, fungibleId) {
        EVT.EvtLink.getEvtLinkForPayeeCode({address: evtpublic, fungibleId: fungibleId || 0}).then(
          function(result){BNMessage("evt_payeeCode", null, result)}
        ).catch(
          function(err){BNMessage("evt_payeeCode", err)}
        )
      }

      /**
       * get Fungible Balances
       * @param  string publicKey
       */
      function evt_getFungibleBalance(publicKey) {
        apiCaller.getFungibleBalance(publicKey).then(function(result){BNMessage("evt_getFungibleBalance", null, result)}).catch(function(err){BNMessage("evt_getFungibleBalance", err)})
      }
      function evt_getFungibleBalanceInfos(publickey) {
        apiCaller.getFungibleBalance(publicKey)
          .then(function(result){
            var infos = []
            result.forEach(function(asset){
              console.log(asset.split("#"))
              apiCaller.getFungibleSymbolDetail(parseInt(asset.split("#")[1])).then(function(detail){
                var iconData = '';
                for (var index = 0; index < detail.metas.length; index++) {
                  if (detail.metas[index].key==="symbol-icon") {
                    iconData = detail.metas[index].value
                  }
                }

                var _sym = detail.sym.split(",S#")
                infos.push({
                  balance: asset,
                  decimals: _sym[0],
                  fungibleId: _sym[1],
                  sym_name: detail.sym_name,
                  name: detail.name,
                  icon: iconData
                })
                if (infos.length == result.length) {
                  BNMessage("evt_getFungibleBalanceInfo", null, infos)
                }
              }).catch(function(err){BNMessage("evt_getFungibleBalanceInfo", err)})
            })
          })
          .catch(function(err){BNMessage("evt_getFungibleBalanceInfo", err)})
      }

      /**
       * get Managed Groups
       * @param  string publicKey
       */
      function evt_getManagedGroups(publicKey) {
        apiCaller.getManagedGroups(publicKey).then(function(result){BNMessage("evt_getManagedGroups", null, result)}).catch(function(err){BNMessage("evt_getManagedGroups", err)})
      }

      /**
       * get Created Domains
       * @param  string publicKey
       */
      function evt_getCreatedDomains(publicKey) {
        apiCaller.getCreatedDomains(publicKey).then(function(result){BNMessage("evt_getCreatedDomains", null, result)}).catch(function(err){BNMessage("evt_getCreatedDomains", err)})
      }

      /**
       * get Owned Tokens
       * @param  string publicKey
       */
      function evt_getOwnedTokens(publicKey) {
        apiCaller.getOwnedTokens(publicKey).then(function(result){BNMessage("evt_getOwnedTokens", null, result)}).catch(function(err){BNMessage("evt_getOwnedTokens", err)})
      }

      /**
       * get Fungible Symbol Detail
       * @param  string symbol eg. EVT
       * @return {[type]} 
       */
      function evt_getFungibleSymbolDetail(symbol) {
        apiCaller.getFungibleSymbolDetail(symbol).then(function(result){BNMessage("evt_getFungibleSymbolDetail", null, result)}).catch(function(err){BNMessage("evt_getFungibleSymbolDetail", err)})
      }

      /**
       * get Created Fungibles
       * @param  string publicKey
       * @return {[type]}
       */
      function evt_getCreatedFungibles(publicKey) {
        apiCaller.getCreatedFungibles(publicKey).then(function(result){BNMessage("evt_getCreatedFungibles", null, result)}).catch(function(err){BNMessage("evt_getCreatedFungibles", err)})
      }

      /**
       * getTransactionIdForLinkId
       * @param  string linkId
       * @return {[type]}
       */
      function evt_getTransactionIdForLinkId(linkId) {
        apiCaller.getTransactionIdForLinkId(linkId).then(function(result){BNMessage("evt_getTransactionIdForLinkId", null, result.trx_id)}).catch(function(err){BNMessage("evt_getTransactionIdForLinkId", err)})
      }
      
      /**
       * getGroupDetail
       * @param  string group
       * @return {[type]}
       */
       function evt_getGroupDetail(group) {
        apiCaller.getGroupDetail(group).then(function(result){BNMessage("evt_getGroupDetail", null, result)}).catch(function(err){BNMessage("evt_getGroupDetail", err)})
      }

      /**
       * getDomainDetail
       * @param  {string} domain
       * @return {[type]}
       */
      function evt_getDomainDetail(domain) {
        apiCaller.getDomainDetail(domain).then(function(result){BNMessage("evt_getDomainDetail", null, result)}).catch(function(err){BNMessage("evt_getDomainDetail", err)})
      }

      // get TransactionDetailById
      function evt_getTransactionDetailById(txId) {
        apiCaller.getTransactionDetailById(txId).then(function(result){BNMessage("evt_getTransactionDetailById", null, result)}).catch(function(err){BNMessage("evt_getTransactionDetailById", err)})
      }

      function evt_getTransactionNumberById(txId) {
        apiCaller.getTransactionDetailById(txId).then(function(result){
          BNMessage("evt_getTransactionDetailById", null, result.transaction.actions[0].data.number)}
        ).catch(function(err){BNMessage("evt_getTransactionDetailById", err)})
      }

      /**
       * evt_evt2pevt
       * @param  string password
       * @param  objcet abi eg. {"from": `address`, "to": `address`, "number": `asset`, "memo": `string`}
       * @return {[type]}
       */
      function evt_evt2pevt(password, abi) {
        passport.setPwd(password)
        _evtPushTransaction("evt_evt2pevt", [new EVT.EvtAction("evt2pevt", abi)])
      }
      /**
       * add meta info
       * @param  string password
       * @param  objcet abi eg. {key: "mark1", value: "something", creator: "[A] EVT85QEkmFpnDwR4NjnYenqenyCxFRQc45HwjGLNpXQQ1JuSmBzSj"}
       * @param  string domain
       * @param  string key
       * @return {[type]}          [description]
       */
      function evt_addmeta(password, abi, domain, key) {
        passport.setPwd(password)
        key = key || ".meta"
        if (abi.creator === "") {
          abi.creator = "[A] " + wallets.evt.getAddresses()[0]
        }
        _evtPushTransaction("evt_addmeta", [new EVT.EvtAction("addmeta", abi, domain, key)])
      }

      /**
       * get Token info
       * @param  string domain
       * @param  string token
       * @return {[type]}        [description]
       */
      function evt_getToken(domain, token) {
        apiCaller.getToken(domain,token).then(function(result){BNMessage("evt_getToken", null, result)}).catch(function(err){BNMessage("evt_getToken", err)})
      }

      function evt_destroytoken(password, domain, token) {
        passport.setPwd(password)
        _evtPushTransaction("evt_destroytoken", [new EVT.EvtAction("destroytoken", {domain: domain,name: token})])
      }

      /**
       * create newgroup
       * @param  {string} password
       * @param  {boject} group    group def
       * @return {[type]}          [description]
       */
       function evt_newgroup(password, group) {
        passport.setPwd(password)
        _evtPushTransaction("evt_newgroup", [new EVT.EvtAction("newgroup",{name: group.name, group: group})])
      }

      /**
       * update group
       * @param  {string} password
       * @param  {boject} group    group def
       * @return {[type]}          [description]
       */
       function evt_updategroup(password, group) {
        passport.setPwd(password)
        _evtPushTransaction("evt_updategroup", [new EVT.EvtAction("updategroup",{name: group.name, group: group})])
      }

      /**
       * create newdomain
       * @param  string password
       * @param  string domain
       * @param  object authorization prototype include issue,transfer,manage @see EVT permission_def
       * @return {[type]}               [description]
       */
      function evt_newdomain(password, domain, authorization) {
        passport.setPwd(password)
        var creator = wallets.evt.getAddresses()[0]
        var abi = {
          "name": domain,
          "creator": creator
        }
        _authorization(authorization, abi)

        _evtPushTransaction("evt_newdomain", [new EVT.EvtAction("newdomain", abi)])
      }

      function evt_updatedomain(password, domain, authorization) {
        passport.setPwd(password)
        var creator = wallets.evt.getAddresses()[0]
        authorization.name = domain

        _evtPushTransaction("evt_updatedomain", [new EVT.EvtAction("updatedomain", authorization)])
      }

      /**
       * Issue Non-Fungible Tokens
       * @param  string password
       * @param  string domain
       * @param  array  names    list of token name
       * @param  array  owner    list of publickey,address
       * @return {[type]}        [description]
       */
      function evt_issuetoken(password, domain, names, owner) {
        passport.setPwd(password)
        _evtPushTransaction("evt_issuetoken", [new EVT.EvtAction("issuetoken", {"domain": domain, "names": names, "owner": owner})])
      }

      /**
       * issue fungible asset
       * @param  string password
       * @param  object abi      {"address": publicKey, "number": asset,"memo": memo}
       * @return {[type]}          [description]
       */
      function evt_issuefungible(password, abi) {
        passport.setPwd(password)
        var info = _parseAsset(abi.number)
        if (!info) {
          return BNMessage("evt_issuefungible", "asset error")
        }
        _evtPushTransaction("evt_issuefungible", [new EVT.EvtAction("issuefungible", abi,".fungible",info[2])])
      }

      /**
       * transfer fungible asset
       * @param  string password
       * @param  objcet abi      {"from": publicKey,"to": publicKey2,"number": "10.00 YYA","memo": "memo"}
       * @return {[type]}          [description]
       */
      function evt_transferft(password, abi) {
        passport.setPwd(password)
        var info = _parseAsset(abi.number)
        if (!info) {
          return BNMessage("evt_transferft", "asset error")
        }
        _evtPushTransaction("evt_transferft", [new EVT.EvtAction("transferft", abi,".fungible", info[2])])
      }

      function evt_multiTransferft(password, abis) {
        passport.setPwd(password)
        var info = _parseAsset(abis[0].number)
        if (!info) {
          return BNMessage("evt_multiTransferft", "asset error")
        }

        var acts = [];
        abis.forEach(function(abi){
          acts.push(new EVT.EvtAction("transferft", abi,".fungible", info[2]))
        })
        _evtPushTransaction("evt_multiTransferft", acts)
      }

      /**
       * Fungible transfer lists
       * @param  int    fungible id
       * @param  string address
       * @param  int    skip=0   started number
       * @param  int    take=10  perPage numbere
       * @return {[type]}          [description]
       */
      function evt_getFungibleActionsByAddress(fid, address, skip, take) {
        skip = skip || 0
        take = take || 10
        apiCaller.getFungibleActionsByAddress(fid, address, skip, take)
        .then(function(result){
          var list = [],item = {}
          for (var i = 0; i < result.length; i++) {
            item = {
              createdAt: result[i].created_at,
              action: result[i].name,
              to: "",
              from: "",
              number: result[i].data.number,
              memo: result[i].data.memo,
              trxId: result[i].trx_id
            }

            switch (item.action) {
              case "issuefungible":
                item.to = result[i].data.address
                break;
              case "everipay":
                item.to = result[i].data.payee
                item.from = address
                break;
            
              default: // transferft
                item.to = result[i].data.to
                item.from = result[i].data.from
                break;
            }

            list.push(item)
          }
          BNMessage("evt_getFungibleActionsByAddress", null, list)
        })
        .catch(function(err){BNMessage("evt_getFungibleActionsByAddress", err)})
      }

      /**
       * transfer Token
       * @param  string password
       * @param  objcet abi      {domain: "org.ding.a", name: "token_name", to: ["address"], memo: "string"}
       * @return {[type]}          [description]
       */
      function evt_transfer(password, abi) {
        passport.setPwd(password)
        _evtPushTransaction("evt_transfer", [new EVT.EvtAction("transfer", abi)])
      }

      /**
       * n-Fungible transfer logs
       * @param  string domain
       * @param  string name
       * @param  int    skip=0   started number
       * @param  int    take=10  perPage numbere
       * @return {[type]}          [description]
       */
      function evt_nftTransferLogs(domain, name, skip, take) {
        apiCaller.getActions({domain: domain, key: name, skip: skip || 0, take: take || 10, names:["transfer"]})
          .then(function(result){
            var list = []
            for (var i = 0; i < result.length; i++) {
              list.push({
                createdAt: result[i].created_at,
                to: result[i].data.to,
                trxId: result[i].trx_id
              })
            }
            BNMessage("evt_nftTransferLogs", null, list)
          })
          .catch(function(err){BNMessage("evt_nftTransferLogs", err)})
      }

      /**
       * newfungible
       * @param  string password      [description]
       * @param  string totalSupply   asset type eg "10000.00000 S#1"
       * @param  string symName       asset symname eg "EVT"
       * @param  string name          asset name eg "evriToken"
       * @param  objcet authorization prototype include issue,transfer,manage @see EVT permission_def
       * @return {[type]}               [description]
       */
      function evt_newfungible(password, totalSupply, symName, name, authorization, icon) {
        passport.setPwd(password)
        var creator = wallets.evt.getAddresses()[0]
        var info = _parseAsset(totalSupply)
        if (!info) {
          return BNMessage("evt_newfungible", "totalSupply error")
        }

        var sym = [info[1]?info[1].length-1:"0", info[2]].join(",S#")


        var abi = {
            "sym": sym,
            "sym_name": symName,
            "name": name || symName,
            "creator": creator,
            "total_supply": totalSupply
        }
        _authorization(authorization, abi)

        var actions = []
        actions.push(new EVT.EvtAction("newfungible",abi))
        actions.push(new EVT.EvtAction("addmeta", {
            "key": "symbol-icon",
            "value": icon,
            "creator": "[A] " + creator
          }, ".fungible", info[2]))

        _evtPushTransaction("evt_newfungible", actions)
      }

      /**
       * update fungible
       * @param  string password
       * @param  integer sym           eg "5"
       * @param  objcet authorization prototype include issue,transfer,manage @see EVT permission_def
       * @return {[type]}               [description]
       */
      function evt_updfungible(password, sym, authorization) {
        passport.setPwd(password)
        authorization.sym_id = sym
        _evtPushTransaction("evt_updfungible", [new EVT.EvtAction("updfungible", authorization)])
      }

      function _parseAsset(asset) {
        return /^\d+(\.\d+)?\ S#(\d+)$/.exec(asset)
      }

      function _authorization(au, abi) {
        if (typeof au !== "object") {
          throw new Error("authorization must object")
        }
        // issue
        if ("issue" in au) {
          if (au.issue === "creator") {
            abi.issue = {
              "name":"issue",
              "threshold": 1,
              "authorizers": [{
                "ref": "[A] " + abi.creator,
                "weight": 1
              }]
            }
          } else {
            abi.issue = au.issue
          }
        }

        // manage
        if ("manage" in au) {
          if (au.manage === "creator") {
            abi.manage = {
              "name":"manage",
              "threshold": 1,
              "authorizers": [{
                  "ref": "[A] " + abi.creator,
                  "weight": 1
              }]
            }
          } else {
            abi.manage = au.manage
          }
        }

        // manage
        if ("transfer" in au) {
          if (au.transfer === "owner") {
            abi.transfer = {
              "name": "transfer",
              "threshold": 1,
              "authorizers": [{
                  "ref": "[G] .OWNER",
                  "weight": 1
              }]
            }
          } else {
            abi.transfer = au.transfer
          }
        }
      }

      function _evtPushTransaction(target, evtActions) {
        var act = "";
        if (passport.getPwd()) {
          act = "pushTransaction"
          evtActions.unshift(evtKeyProviders.pushConfig())
        } else {
          target = "_getEstimatedCharge"
          act = "getEstimatedChargeForTransaction"
          evtActions.unshift({
            availablePublicKeys: evtKeyProviders.addresses(true),
            payer: wallets.evt.getAddresses()[0]
          })
        }
        try {
          apiCaller[act].apply(apiCaller, evtActions).then(function(result){BNMessage(target, null, result)}).catch(function(err){BNMessage(target, err)})
        } catch (error) {
          BNMessage(target, error)
        }
      }

      /**
       * eos transfer
       * @param  string password
       * @param  objcet abi      {"from": publicKey,"to": publicKey2,"number": "10.00 YYA","memo": "memo"}
       */
      function eos_transfer(password, tx, contract) {
        passport.setPwd(password)
        contract = contract || 'eosio.token'

        var p = {}
        if (contract === 'eosio.token') {
          p = eos.transfer(tx.from, tx.to, tx.number, tx.memo)
        } else {
          eos.transaction({
            actions:[
              {
                account: contract,
                name: 'transfer',
                authorization: [{
                  actor: tx.from,
                  permission: 'active'
                }],
                data: { from: tx.from, to: tx.to, quantity: tx.number, memo: tx.memo }
              }
            ]
          })
        }
        p.then(function(result){BNMessage("eos_transfer", null, result.transaction_id)}).catch(function(err){BNMessage("eos_transfer", err)})
      }

      function eos_getCurrencyBalance(code, account, symbol) {
        eos.getCurrencyBalance(code, account, symbol || null).then(function(result){BNMessage("eos_getCurrencyBalance", null, result)}).catch(function(err){BNMessage("eos_getCurrencyBalance", err)})
      }

      function eos_getKeyAccounts(publicKey) {
        eos.getKeyAccounts(publicKey).then(function(result){BNMessage("eos_getKeyAccounts", null, result.account_names)}).catch(function(err){BNMessage("eos_getKeyAccounts", err)})
      }

      function eos_getAccount(account) {
        eos.getAccount(account).then(function(result){BNMessage("eos_getAccount", null, result)}).catch(function(err){BNMessage("eos_getAccount", err)})
      }

      function getEthERC20ABI() {
        return [{"constant":true,"inputs":[],"name":"name","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_value","type":"uint256"}],"name":"approve","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_from","type":"address"},{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transferFrom","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"INITIAL_SUPPLY","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"decimals","outputs":[{"name":"","type":"uint8"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_subtractedValue","type":"uint256"}],"name":"decreaseApproval","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"}],"name":"balanceOf","outputs":[{"name":"balance","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"name":"","type":"string"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"name":"_to","type":"address"},{"name":"_value","type":"uint256"}],"name":"transfer","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"name":"_spender","type":"address"},{"name":"_addedValue","type":"uint256"}],"name":"increaseApproval","outputs":[{"name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"name":"_owner","type":"address"},{"name":"_spender","type":"address"}],"name":"allowance","outputs":[{"name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"inputs":[],"payable":false,"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"name":"owner","type":"address"},{"indexed":true,"name":"spender","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"name":"from","type":"address"},{"indexed":true,"name":"to","type":"address"},{"indexed":false,"name":"value","type":"uint256"}],"name":"Transfer","type":"event"}]
      }

      /**
       * get token balance
       * @param  string  address
       * @param  []string  tokenAddresses
       * @return {[type]}               [description]
       */
      function eth_tokenBalance(address, tokenAddresses) {
        var result = [], count=0
        if (typeof tokenAddresses === "string") {
          tokenAddresses = [tokenAddresses]
        }
        var contract = web3.eth.contract(getEthERC20ABI())
        tokenAddresses.forEach(function(at, index){
          try {
            result.push({
              address: at,
              value: contract.at(at).balanceOf(address).toString()
            })
          } catch (error) {
            console.log(index, at)
          }
          count = count + 1
          if (count===tokenAddresses.length) {
            BNMessage("eth_tokenBalance", null, result)
          }
        })
      }

      /**
       * get eth basecoin balance
       * @param  string  address
       * @return {[type]}               [description]
       */
      function eth_getBalance(address) {
        try {
          var balance = web3.eth.getBalance(address)
          BNMessage("eth_getBalance", null, balance.toString())
        } catch (error) {
          BNMessage("eth_getBalance", error.message)
        }
      }

      /**
       * get eth basecoin balance
       * @param  string  password
       * @param  objcet  txParams eg. {from: fromAddr, to: toAddr, value: value, gasPrice: gasPrice, gas: gas}
       * @return {[type]}               [description]
       */
      function eth_sendTransaction(password, txParams) {
        passport.setPwd(password)
        web3.eth.sendTransaction(txParams, function (err, txhash) {
          if (err) {
            console.log(err)
            BNMessage("eth_sendTransaction", err.message)
          } else {
            BNMessage("eth_sendTransaction", null, txhash)
          }
        })
      }

      /**
       * ERC20 calls
       * @param  object  where    eg. {address: 'ERC20 address', method: "contract method", password:"if use"}
       * @param  array   args     the contract method inputs
       * @param  object  txParams the eth transaction object
       * @return {[type]}               [description]
       */
      function eth_contractCall(where, args, txParams) {
        if (typeof args === "string") {
          args = [args]
        }

        if (where.method === "transfer") {
          args[1] = parseFloat(args[1])
        }

        if (typeof txParams === "object") {
          args.push(_eth_txParams(txParams))
        }

        if ("password" in where && where.password) {
          passport.setPwd(where.password)
        }

        var contract = web3.eth.contract(getEthERC20ABI()).at(where.address)
        var callback = function(err, txhash) {
          if (err) {
            console.log(err)
            BNMessage("eth_contractCall", err.message)
          } else {
            BNMessage("eth_contractCall", null, txhash)
          }
        }
        args.push(callback)
        contract[where.method].apply(this, args)
      }

      function eth_getTransaction(trx_id) {
        var trx = web3.eth.getTransaction(trx_id)
        if (trx) {
          BNMessage("eth_getTransaction", null, trx)
        } else {
          BNMessage("eth_getTransaction", "Not found")
        }
      }

      function eth_getTransactionReceipt(trx_id) {
        var trx = web3.eth.getTransactionReceipt(trx_id)
        var status = 0
        if (trx && trx.status) {
          status = web3.toDecimal(trx.status)
        }
        BNMessage("eth_getTransaction", null, status)
      }

      function _eth_txParams(tx) {
        var _tx = Object.create({
          from: wallets.eth.getAddresses()[0],
          value: 0,
          gasPrice: 18000000000,
          gas: 50000
        })
        Object.keys(tx).forEach(function(key){
          _tx[key] = tx[key]
        })
        _tx.value = parseFloat(_tx.value)
        _tx.gasPrice = parseFloat(_tx.gasPrice)
        _tx.gas = parseFloat(_tx.gas)
        return tx
      }
      
    </script>
  </body>
</html>
