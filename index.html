<html>
  <body>
    <script type="text/javascript" src="js/evt.js"></script>
    <script type="text/javascript" src="js/keythereum.js"></script>
    <script type="text/javascript" src="js/myWallet.min.js"></script>
    <script type="text/javascript" src="js/web3.js"></script>
    <script type="text/javascript" src="js/hooked-web3-provider.js"></script>
    <script type="text/javascript">

      var passwordProvider = function() {}
      passwordProvider.prototype.setPwd = function(password) {
        this.password = password;
      }
      passwordProvider.prototype.getPwd = function() {
        password = this.password
        return password
      }

      var evtKeyProviders = (function(){
        var p = function(){
          this.keys = []
        }
        p.prototype.import = function(privKey, publicKey) {
          this.keys.push({key:privKey, addr: publicKey})
          BNOK("evtKeyProviders.import")
        }
        p.prototype.export = function(curPrivKey) {
          var k = [curPrivKey]
          this.keys.map(_k=>{k.push(_k.key)})
          this.keys = []
          return k
        }

        p.prototype.addresses = function() {
          var addrs = []
          this.keys.map(_k=>{addrs.push(_k.addr)})
          BNMessage("evtKeyProviders.addresses", null, addrs)
        }

        return new p()
      })()

      // myWallet.HDkey.generateMnemonic() 助记词
      // web3.eth.sendTransaction({from: '627306090abab3a6e1400e9345bc60c78a8bef57', to: "f17f52151ebef6c7334fad080c5704d77216b732", value: 10*1.0e18, gasPrice: 18000000000, gas: 50000},(err, txid)=>console.log(err,txid))
      var web3 = new Web3();
      var apiCaller = new EVT();
      var wallets = {};
      var passport = new passwordProvider();
      // 需要用到密码钱先设置用户密码 passport.setPwd('password')
      /**
       * 创建钱包
       * @param  {type:"evt",seedPhrase:"candy maple cake sugar pudding cream honey rich smooth crumble sweet treat",hdPathString:"m/44'/207'/0'/0",password:"abcd1234"}
       * @return {[type]}         [description]
       */
      function createHDkey(options) {
        myWallet.HDkey.create(options,(error, ks)=>{
          initHDkey(ks);
          BNMessage("createHDkey", error, ks.serialize());
        });
      }

      /**
       * generateMnemonic
       * @return {[type]} [description]
       */
      function generateMnemonic()
      {
        var words = myWallet.HDkey.generateMnemonic()
        BNMessage("generateMnemonic", null, words);
      }

      /**
       * exportMnemonic
       * @param  string password
       * @param  string ksName
       * @return {[type]}          [description]
       */
      function exportMnemonic(password, ksName)
      {
        if (typeof wallets[ksName] === "undefined") {
          throw new Error("Please initHDkey first!")
        }
        var ks = wallets[ksName]
        ks.keyFromPassword(password,(err,pw)=>{
          if (!ks.isDerivedKeyCorrect(pw)) {
            BNMessage("exportMnemonic", "Password error")
          } else {
            var words = wallets[ksName].getMnemonic(pw)
            BNMessage("exportMnemonic", null, words)
          }
        })
      }

      
      /**
       * exportKeystore
       * @param  string password [description]
       * @param  string ksName   [description]
       */
      function exportKeystore(password, ksName) {
        if (typeof wallets[ksName] === "undefined") {
          throw new Error("Please initHDkey first!")
        }

        var ks = wallets[ksName]
        ks.keyFromPassword(password,(err,pw)=>{
          if (!ks.isDerivedKeyCorrect(pw)) {
            BNMessage('exportKeystore', "Password error")
          } else {
            var prik = ks.exportPrivateKey(ks.getAddresses()[0], pw)
            var dk = keythereum.create({ivBytes: 16 })
            dk.privateKey = keythereum.str2buf(prik)
            var options = {
              kdf: "pbkdf2",
              cipher: "aes-128-ctr",
              kdfparams: {
                c: 262144,
                dklen: 32,
                prf: "hmac-sha256"
              }
            }
            var keyObject = keythereum.dump(password, dk.privateKey, dk.salt, dk.iv, options)
            BNMessage("exportKeystore", null, keyObject)
          }
        })
      }

      /**
       * exportPrivatekey
       * @param  string password
       * @param  string ksName
       * @return {[type]}          [description]
       */
      function exportPrivatekey(password, ksName) {
        if (typeof wallets[ksName] === "undefined") {
          throw new Error("Please initHDkey first!")
        }

        var ks = wallets[ksName]
        ks.keyFromPassword(password,(err,pw)=>{
          if (!ks.isDerivedKeyCorrect(pw)) {
            BNMessage('exportPrivatekey', "Password error")
          } else {
            var prik = ks.exportPrivateKey(ks.getAddresses()[0], pw)
            BNMessage("exportPrivatekey", null, prik)
          }
        })
      }

      /**
       * importKeystore
       * @param  string        password
       * @param  string|object ks       keystore or keystore jsonstring
       * @return {[type]}          [description]
       */
      function importKeystore(password, ks) {
        if (typeof ks === "string") {
          ks = JSON.parse(ks)
        }
        try {
          keythereum.recover(password, ks, function (privateKey) {
            initPrivkey(web3.toHex(String.fromCharCode.apply(null, privateKey)).substr(2), password, 'eth')
          });
        } catch(e) {
          BNMessage("importKeystore", e)
        }
      }

      /**
       * checkWalletPassword
       * @param  string password
       * @param  string ks       wallet name
       * @return {[type]}          [description]
       */
      function checkWalletPassword(password, ks) {
        var wallet = wallets[ks]
        wallet.keyFromPassword(password,(err,pw)=>{
          if(wallet.isDerivedKeyCorrect(pw)) {
            BNOK('checkWalletPassword')
          } else {
            BNMessage('checkWalletPassword', "Password error")
          }
        })
      }

      /**
       * initHDkey Mnemonic wallet
       * @param  hdkey objcet or hdkey serialize string
       * @return {[type]}    [description]
       */
      function initHDkey(ks) {
        if (typeof ks === "object" && ks.getAddresses === undefined) {
          ks = JSON.stringify(ks)
        }

        if (typeof ks === "string") {
          ks = myWallet.HDkey.unserialize(decodeURIComponent(ks))
        }

        if (ks.type === undefined) {
          throw new Error("initHDkey")
        }

        if (ks.type == 'eth') {
          ks.passwordProvider = function(cb) {
            cb(null,  passport.getPwd())
          }
        }

        wallets[ks.type] = ks
        BNOK("initHDkey");
      }

      /**
       * initPrivkey
       * @param  string privKey
       * @param  string password
       * @param  string type     wallet name
       * @return {[type]}          [description]
       */
      function initPrivkey(privKey, password, type)
      {
        var addr = '';
        if (type == 'eth') {
          addr = "0x" + myWallet.pks.privkey2address(privKey)
        } else if(type=="eos") {
          addr = "EOS" + EVT.EvtKey.privateToPublic(privKey).substr(3)
        } else {
          addr = EVT.EvtKey.privateToPublic(privKey)
        }
        myWallet.pks.create({privKey:privKey, password:password, address:addr},(err,k)=>{
          if (err) {
            return BNMessage('initPrivkey', err)
          }
          wallets[type] = k
          BNMessage('initPrivkey', null, k)
        })
      }

      /**
       * init Privkey Wallet
       * @param  string|object ks   privkey object
       * @param  string type   wallet name
       * @return {[type]}      [description]
       */
      function initPrivkeyWallet(ks, type) {
        if (typeof ks === "object") {
          ks = JSON.stringify(ks)
        }
        wallets[type]=myWallet.pks.unserialize(ks)
        BNOK("initPrivkeyWallet")
      }

      /**
       * set Web3js Provider
       * @param string host eth node
       */
      function setWeb3Provider(host) {
        if (wallets.eth === undefined) {
          return BNMessage("setWeb3Provider","Please initHDkey first!");
        }

        wallets.eth.passwordProvider = function(cb) {
          cb(null, passport.getPwd())
        }

        var web3Provider = new HookedWeb3Provider({
          host: host,
          transaction_signer: wallets.eth
        });

        web3.setProvider(web3Provider)
        BNOK("setWeb3Provider")
      }

      /**
       * setEvtProvider 
       * 
       * @param object network eg. {
            host: 'testnet1.everitoken.io',
            port: 8888,
            protocol: 'https'
          }
       */
      function setEvtProvider(network) {
        if (wallets.evt === undefined) {
          return BNMessage("setEvtProvider", "Please initHDkey first!");
        }
        var ks = wallets.evt

        apiCaller.config.endpoint = network
        apiCaller.config.keyProvider = function(transaction) {
          var password = passport.getPwd();
          return new Promise((resolve, reject)=>{
            ks.keyFromPassword(password,(err,pw)=>{
              if (err || !ks.isDerivedKeyCorrect(pw)) {
                reject("Password error")
              } else {
                var keys = evtKeyProviders.export(ks.exportPrivateKey(ks.getAddresses()[0], pw))
                resolve(keys)
              }
            })
          })
        }

        BNOK("setEvtProvider")
      }



      function BNMessage(target, error, result){
        passport.setPwd("")
        if (typeof result !== "string") {
          result = JSON.stringify(result)
        }
        var data = {}
        if (error) {
          if (typeof error === "object") {
            console.log(error)
            error = error.message
          }
          data = {target: target, error:1, errorMessage: error}
        } else {
          data = {target: target, error:0, data: result}
        }
        var dataStr = '';
        Object.keys(data).forEach(function(key){
          dataStr += key+'='+encodeURIComponent(data[key])+'&';
        })
        console.log(data);
        // window.location.href = "wallet://return?" + dataStr
      }

      function BNOK(target)
      {
        BNMessage(target, null, "OK");
      }

      /**
       * get Fungible Balances
       * @param  string publicKey
       */
      function evt_getFungibleBalance(publicKey) {
        apiCaller.getFungibleBalance(publicKey).then(result=>{BNMessage("evt_getFungibleBalance", null, result)}).catch(err=>{BNMessage("evt_getFungibleBalance", err)})
      }

      /**
       * get Managed Groups
       * @param  string publicKey
       */
      function evt_getManagedGroups(publicKey) {
        apiCaller.getManagedGroups(publicKey).then(result=>{BNMessage("evt_getManagedGroups", null, result)}).catch(err=>{BNMessage("evt_getManagedGroups", err)})
      }

      /**
       * get Created Domains
       * @param  string publicKey
       */
      function evt_getCreatedDomains(publicKey) {
        apiCaller.getCreatedDomains(publicKey).then(result=>{BNMessage("evt_getCreatedDomains", null, result)}).catch(err=>{BNMessage("evt_getCreatedDomains", err)})
      }

      /**
       * get Owned Tokens
       * @param  string publicKey
       */
      function evt_getOwnedTokens(publicKey) {
        apiCaller.getOwnedTokens(publicKey).then(result=>{BNMessage("evt_getOwnedTokens", null, result)}).catch(err=>{BNMessage("evt_getOwnedTokens", err)})
      }

      /**
       * get Fungible Symbol Detail
       * @param  string symbol eg. EVT
       * @return {[type]} 
       */
      function evt_getFungibleSymbolDetail(symbol) {
        apiCaller.getFungibleSymbolDetail(symbol).then(result=>{BNMessage("evt_getFungibleSymbolDetail", null, result)}).catch(err=>{BNMessage("evt_getFungibleSymbolDetail", err)})
      }

      
      /**
       * getGroupDetail
       * @param  string group
       * @return {[type]}
       */
       function evt_getGroupDetail(group) {
        apiCaller.getGroupDetail(group).then(result=>{BNMessage("evt_getGroupDetail", null, result)}).catch(err=>{BNMessage("evt_getGroupDetail", err)})
      }

      /**
       * getDomainDetail
       * @param  {string} domain
       * @return {[type]}
       */
      function evt_getDomainDetail(domain) {
        apiCaller.getDomainDetail(domain).then(result=>{BNMessage("evt_getDomainDetail", null, result)}).catch(err=>{BNMessage("evt_getDomainDetail", err)})
      }

      /**
       * evt_evt2pevt
       * @param  string password
       * @param  objcet abi eg. {"from": `address`, "to": `address`, "number": `asset`, "memo": `string`}
       * @return {[type]}
       */
       function evt_evt2pevt(password, abi) {
        passport.setPwd(password)
        apiCaller.pushTransaction(
          {maxCharge: 100000},
          new EVT.EvtAction("evt2pevt", abi)
        ).then(result=>{BNMessage("evt_evt2pevt", null, result)}).catch(err=>{BNMessage("evt_evt2pevt", err)})
      }
      /**
       * add meta info
       * @param  string password
       * @param  objcet abi eg. {key: "mark1", value: "something", creator: "[A] EVT85QEkmFpnDwR4NjnYenqenyCxFRQc45HwjGLNpXQQ1JuSmBzSj"}
       * @param  string domain
       * @param  string key
       * @return {[type]}          [description]
       */
      function evt_addmeta(password, abi, domain, key) {
        passport.setPwd(password)
        key = key || ".meta"
        apiCaller.pushTransaction(
          {maxCharge: 100000},
          new EVT.EvtAction("addmeta", abi, domain, key)
        ).then(result=>{BNMessage("evt_addmeta", null, result)}).catch(err=>{BNMessage("evt_addmeta", err)})
      }

      /**
       * get Token info
       * @param  string domain
       * @param  string token
       * @return {[type]}        [description]
       */
      function evt_getToken(domain, token) {
        apiCaller.getToken(domain,token).then(result=>{BNMessage("evt_getToken", null, result)}).catch(err=>{BNMessage("evt_getToken", err)})
      }

      /**
       * create newgroup
       * @param  {string} password
       * @param  {boject} group    group def
       * @return {[type]}          [description]
       */
       function evt_newgroup(password, group) {
        passport.setPwd(password)
        apiCaller.pushTransaction(
          {maxCharge: 100000},
          new EVT.EvtAction("newgroup",{
            name: group.name,
            group: group
          })
        ).then(result=>{BNMessage("evt_newgroup", null, result)}).catch(err=>{BNMessage("evt_newgroup", err)})
      }

      /**
       * create newdomain
       * @param  string password
       * @param  string domain
       * @param  object authorization prototype include issue,transfer,manage @see EVT permission_def
       * @return {[type]}               [description]
       */
      function evt_newdomain(password, domain, authorization) {
        passport.setPwd(password)
        var creator = wallets.evt.getAddresses()[0]
        var abi = {
          "name": domain,
          "creator": creator
        }
        _authorization(authorization, abi)

        apiCaller.pushTransaction(
          {maxCharge: 100000},
          new EVT.EvtAction("newdomain", abi)
        ).then(result=>{BNMessage("evt_newdomain", null, result)}).catch(err=>{BNMessage("evt_newdomain", err)})
      }

      /**
       * Issue Non-Fungible Tokens
       * @param  string password
       * @param  string domain
       * @param  array  names    list of token name
       * @param  array  owner    list of publickey,address
       * @return {[type]}        [description]
       */
      function evt_issuetoken(password, domain, names, owner) {
        passport.setPwd(password)
        apiCaller.pushTransaction(
          {maxCharge: 100000},
          new EVT.EvtAction("issuetoken", {
            "domain": domain,
            "names": names,
            "owner": owner
          })
        ).then(result=>{BNMessage("evt_issuetoken", null, result)}).catch(err=>{BNMessage("evt_issuetoken", err)})
      }

      /**
       * issue fungible asset
       * @param  string password
       * @param  object abi      {"address": publicKey, "number": asset,"memo": memo}
       * @return {[type]}          [description]
       */
      function evt_issuefungible(password, abi) {
        passport.setPwd(password)
        var info = _parseAsset(abi.number)
        if (!info) {
          return BNMessage("evt_issuefungible", "asset error")
        }
        apiCaller.pushTransaction(
          {maxCharge: 100000},
          new EVT.EvtAction("issuefungible", abi,".fungible",info[2])
        ).then(result=>{BNMessage("evt_issuefungible", null, result)}).catch(err=>{BNMessage("evt_issuefungible", err)})
      }

      /**
       * transfer fungible asset
       * @param  string password
       * @param  objcet abi      {"from": publicKey,"to": publicKey2,"number": "10.00 YYA","memo": "memo"}
       * @return {[type]}          [description]
       */
      function evt_transferft(password, abi) {
        passport.setPwd(password)
        var info = _parseAsset(abi.number)
        if (!info) {
          return BNMessage("evt_transferft", "asset error")
        }
        apiCaller.pushTransaction(
          {maxCharge: 100000},
          new EVT.EvtAction("transferft", abi,".fungible", info[2])
        ).then(result=>{BNMessage("evt_transferft", null, result)}).catch(err=>{BNMessage("evt_transferft", err)})
      }

      /**
       * transfer Token
       * @param  string password
       * @param  objcet abi      {domain: "org.ding.a", name: "token_name", to: ["address"], memo: "string"}
       * @return {[type]}          [description]
       */
      function evt_transfer(password, abi) {
        passport.setPwd(password)
        apiCaller.pushTransaction(
          {maxCharge: 100000},
          new EVT.EvtAction("transfer", abi)
        ).then(result=>{BNMessage("evt_transfer", null, result)}).catch(err=>{BNMessage("evt_transfer", err)})
      }

      /**
       * newfungible
       * @param  string password      [description]
       * @param  string totalSupply   asset type eg "10000.00000 EVT"
       * @param  objcet authorization prototype include issue,transfer,manage @see EVT permission_def
       * @return {[type]}               [description]
       */
      function evt_newfungible(password, totalSupply, authorization, icon) {
        passport.setPwd(password)
        var creator = wallets.evt.getAddresses()[0]
        var info = _parseAsset(totalSupply)
        if (!info) {
          return BNMessage("evt_newfungible", "totalSupply error")
        }

        var sym = [info[1]?info[1].length-1:"0", info[2]].join(",")


        var abi = {
            "sym": sym,
            "creator": creator,
            "total_supply": totalSupply
        }
        _authorization(authorization, abi)

        apiCaller.pushTransaction(
          {maxCharge: 100000}, 
          new EVT.EvtAction("newfungible",abi),
          new EVT.EvtAction("addmeta", {
            "key": "symbol-icon",
            "value": icon,
            "creator": "[A] " + creator
          },".fungible",info[2])
        ).then(result=>{BNMessage("evt_newfungible", null, result)}).catch(err=>{BNMessage("evt_newfungible", err)})
      }

      function _parseAsset(asset) {
        return /^\d+(\.\d+)?\ (\w+)$/.exec(asset)
      }

      function _authorization(au, abi) {
        if (typeof au !== "object") {
          throw new Error("authorization must object")
        }
        // issue
        if ("issue" in au) {
          if (au.issue === "creator") {
            abi.issue = {
              "name":"issue",
              "threshold": 1,
              "authorizers": [{
                "ref": "[A] " + abi.creator,
                "weight": 1
              }]
            }
          } else {
            abi.issue = au.issue
          }
        }

        // manage
        if ("manage" in au) {
          if (au.manage === "creator") {
            abi.manage = {
              "name":"manage",
              "threshold": 1,
              "authorizers": [{
                  "ref": "[A] " + abi.creator,
                  "weight": 1
              }]
            }
          } else {
            abi.manage = au.manage
          }
        }

        // transfer !FT
        if (typeof abi.sym === "undefined") {
          if (typeof au.transfer === "undefined" || au.transfer === "owner") {
            abi.transfer = {
                "name": "transfer",
                "threshold": 1,
                "authorizers": [{
                    "ref": "[G] .OWNER",
                    "weight": 1
                }]
            }
          } else {
            abi.transfer = au.transfer
          }
        }
        console.log(JSON.stringify(abi))
      }
      
    </script>
  </body>
</html>
